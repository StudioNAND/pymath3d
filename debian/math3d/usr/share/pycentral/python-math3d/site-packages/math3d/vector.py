'''
This file is part of pymath3d.

pymath3d is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

pymath3d is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with pymath3d.  If not, see <http://www.gnu.org/licenses/>.

Revision $Rev$
ID: $Id$

Module implementing the Vector class.
'''

#from Numeric import array,ArrayType,vdot,dot,cross_product,subtract
from types import FloatType,IntType,LongType,InstanceType,ListType,TupleType
from math import sqrt,acos,pi
from copy import copy
import exceptions

from numpy import array,dot,cross,subtract

from math3d.utils import isNumTypes,isNumType,isSequence,isThreeSequence

def isVector(v):
    #return (type(v) == InstanceType and v.__class__ == Vector)
    return type(v) == Vector

class Vector(object):
    ''' A Vector is a 3D vector (member of R3) with standard euclidian
    operations.'''
    
    class Error(exceptions.Exception):
        ''' Exception class.'''
        def __init__(self, message):
            self.message = message
        def __repr__(self):
            return self.__class__ + '.Error :' + self.message

    @classmethod
    def canCreateOn(cls, *arg):
        if type(arg) == cls:
            return True
        elif isSequence(arg):
            if len(arg) <= 3 and isNumTypes(arg):
                return True
            elif len(arg) == 1:
                return cls.canCreateOn(*arg[0])
            else:
                return False
        else:
            return False

    def __init__(self, *args, **kwargs):
        ''' Constructor for Vector. If optional keyword argument
        "position" is evaluates to true, or is not given, the vector
        is represented as a position vector. Otherwise it is
        represented as a real vector.'''
        if len(args) == 3 and isNumTypes(args):
            self._data=array(map(float, args))
        elif len(args) == 2 and isNumTypes(args):
            self._data = array(map(float,[args[0], args[1], 0]))
        elif len(args) == 1:
            arg = args[0]
            if isThreeSequence(arg):
                self._data = array(map(float, arg))
            elif isSequence(arg) and len(arg)  == 2:
                self._data = array(map(float, [arg[0], arg[1], 0]))
            elif isVector(arg):
                self._data = arg._data.copy()
            else:
                raise self.Error,'__init__ : could not create vector on argument :', str(args[0])
        else:
            self._data = array([0.0,0.0,0.0])
        self._isPosition = 1
        if kwargs.has_key('position'):
            if kwargs['position']: self._isPosition = 1
            else: self._isPosition = 0
    
    def __copy__(self):
        '''Copy method for creating a copy of this Vector.'''
        v = Vector()
        v.copy(self)
        return v
    
    def __deepcopy__(self, memo):
        return self.__copy__()
    
    def copy(self, other):
        '''Copy data from other to self. '''
        self._data = copy(other._data)

    def __getattr__(self,name):
        if name == 'data':
            return self._data
        elif name == 'x':
            return self._data[0]
        elif name == 'y':
            return self._data[1]
        elif name == 'z':
            return self._data[2]
        else:
            raise self.Error,'__getattr__ :  No attribute "%s"!'%name
        
    def __setattr__(self,name,val):
        if name == 'x':
            self._data[0] = val
        elif name == 'y':
            self._data[1] = val
        elif name == 'z':
            self._data[2] = val
        elif name == '_data':
            self.__dict__[name] = val
        elif name == 'pos':
            if isVector(val):
                self._data = copy(val._data)
            elif isThreeSequence(val):
                self._data = array(val)
        else:
            self.__dict__[name] = val

    def __coerce__(self, other):
        return None

    def __getitem__(self, n):
        return self._data[n]

    def __setitem__(self,n,val):
        self._data[n] = val

    def __cmp__(self,other):
        if self.x == other.x and self.y == other.y and self.z == other.z: return 0
        else: return cmp(self.x,other.x)

    def __eq__(self,other):
        if isVector(other) and self.x == other.x and self.y == other.y and self.z == other.z: return True
        else: return False

    def __repr__(self):
        return '<Vector: x=%f y=%f z=%f>'%(self.x,self.y,self.z)

    def __str__(self):
        return self.__repr__()
    
    def isPos(self):
        ''' If the vector is a position vector, default, then it
        transforms differently than a real vector.'''
        return self._isPosition

    def angle(self, other):
        '''Return the angle to the other vector. This is the
        absolute, positive angle.'''
        costheta = (self * other) / (self.length() * other.length())
        if costheta > 1:
            costheta = 1
        elif costheta < -1:
            costheta = -1
        return acos(costheta)

    def sangle(self, other, refVec=None):
        '''With default reference rotation vector as Z-axis (if
        refVec == None), compute the signed angle of rotation from self
        to other.'''
        theta = self.angle(other)
        xprod = self.cross(other)
        if not refVec is None:
            if xprod*refVec < 0:
                theta = -theta
        else:
            if xprod.z < 0:
                theta = -theta
        return theta
    
    def length(self):
        '''Standard Euclidean length. '''
        return sqrt(self.length2())

    def length2(self):
        '''Square of the standard Euclidean length. '''
        return dot(self._data, self._data)

    def normalize(self):
        '''In-place normalization of this Vector. '''
        l = self.length()
        if l != 1.0:
            self._data = self._data / l

    def normalized(self):
        '''Returns a normalized Vector with same direction as this
        one.'''
        nv = Vector(self)
        nv.normalize()
        return nv

    def dist(self, other):
        '''Compute euclidean distance between points given by self and
        other.'''
        return (self - other).length()

    def cross(self, other):
        return Vector(cross(self._data, other._data))

    def __sub__(self, other):
        if isVector(other):
            return Vector(subtract(self._data, other._data))

    def __isub__(self, other):
        if isVector(other):
            self._data -= other._data
        return self
    
    def __mul__(self, other):
        ''' Multiplication with an other Vector (dot product) or with a scalar '''
        if isVector(other):
            return dot(self._data, other._data)
        elif isNumType(other):
            return Vector(dot(self._data, other))

    def __imul__(self, other):
        ''' Self multiplication with a scalar. '''
        if isNumType(other):
            self._data *= other
        return self
    
    def __rmul__(self, other):
        ''' Right multiplication with a scalar. '''
        if isNumType(other):
            return Vector(other * self._data)
        else:
            raise self.Error, '__rmul__ : Could not multiply by non-number'
        
    def __div__(self, other):
        ''' Division with a scalar. '''
        if isNumType(other):
            return Vector(1.0 / other * self._data)
        else:
            raise self.Error, '__rdiv__ : Could not divide by non-number'
        
    def __add__(self, other):
        if isVector(other):
            return Vector(self._data + other._data)
        
    def __iadd__(self,other):
        if isVector(other):
            self._data += other._data
        return self

    def __neg__(self):
        return Vector(-self._data)

# Unit Vectors
Vector.e0 = Vector(1,0,0)
Vector.e1 = Vector(0,1,0)
Vector.e2 = Vector(0,0,1)
    
def _test():
    print Vector.canCreateOn(1,2,3), Vector.canCreateOn((1,2,3)), Vector.canCreateOn(1,2)  
