'''
Module implementing the Quaternion class.
'''

import numpy

import math3d
from math3d.utils import isNumType

def isQuaternion(q):
    return type(q) == Quaternion

class Quaternion(object):
    ''' Quaternion class.'''
    
    class Error(Exception):
        ''' Exception class.'''
        def __init__(self, message):
            self.message = message
        def __repr__(self):
            return self.__class__ + '.Error :' + self.message
    
    def __init__(self, *args):
        ''' Create a quaternion. Args may be () for default
        constructor, (Orientation) for createing a quaternion
        representing the given orientation, (Quaternion) for a copy
        constructor, (s,x,y,z) or (s,Vector) for the direct quaternion
        data.'''
        if len(args) == 0:
            ## Default constructor
            self._s = 1.0
            self._v = math3d.Vector()
        elif len(args) == 1:
            ## Try with orientation or quaternion
            if type(args[0]) == math3d.Orientation:
                self._v = math3d.Vector()
                self.fromOrientation(args[0])
            ## Copy constructor
            elif type(args[0]) == Quaternion:
                self._s = args[0]._s
                self._v = args[0]._v.copy()
        elif len(args) == 2:
            ## Assume a scalar and a vector
            self._s = args[0]
            self._v = args[1].copy()
        elif len(args) == 4:
            ## Assume numbers for s, x, y, and z
            self._s = args[0]
            self._v = math3d.Vector(args[1:])
            
    def __repr__(self):
        return '[ %.5f , ( %.5f , %.5f , %.5f ) ]' % (self._s, self._v.x, self._v.y, self._v.z)

    def __copy__(self):
        '''Copy method for creating a copy of this Quaternion.'''
        return Quaternion(self)
    
    def __deepcopy__(self, memo):
        return self.__copy__()
    
    def copy(self, other=None):
        ''' Set this quaternion to a copy of other, if not
        None. Otherwise, return a quaternion which is a copy of this
        quaternion.'''
        if other is None:
            return Quaternion(self)
        else:
            self._s = other._s
            self._v = other._v.copy()
            
    def __mul__(self, other):
        if type(other) == Vector:
            ## Do a rotation of the vector
            return (self * Quaternion(0, other) * self.inverse())._v
        elif type(other) == Quaternion:
            ## Ordinary quaternion multiplication
            return Quaternion(self._s * other._s - self._v * other._v, self._v.cross(other._v) + self._s * other._v + other._s * self._v)
        elif isNumType(other):
            return Quaternion(other * self._s, other * self._v)

    def __rmul__(self, rother):
        ''' Right-multiply by number. '''
        if isNumType(rother):
            return Quaternion(rother * self._s, rother * self._v)

    def __imul__(self, other):
        ''' In-place multiply.'''
        if isNumType(other):
            self._s *= other
            self._v *= other
        return self
            
    def __ipow__(self, x):
        ''' In-place exponentiation of this quaternion to the power of
        "x".'''
        if abs(1 - abs(self._s)) < 1e-7:
            self._s = 1
            self._v = math3d.Vector(0, 0, 0)
        else:
            theta = numpy.arccos(self._s)
            sintheta = numpy.sin(theta)
            logv = theta / sintheta * self._v
            alpha = x * logv.length()
            v = logv.normalized()
            self._s = numpy.cos(alpha)
            self._v = numpy.sin(alpha) * v
        return self

    def __pow__(self, x):
        ''' Return this quaternion to the power of "x".'''
        q = Quaternion(self)
        q **= x
        return q

    def __neg__(self):
        ''' Return the negative quaternion to self.'''
        q = Quaternion(self)
        q *= -1.0
        return q

    def dist(self, other):
        ''' Compute the quaternion distance to other.'''
        return numpy.sqrt((self._s - other._s)**2 + (self._v - other._v).length2())
        
    def toAxisAngle(self):
        ''' Return an angle and axis pair representing the orientation
        of this quaternion.'''
        theta = 2 * numpy.arccos(self._s)
        if theta != 0:
            w = self._v / numpy.sin(theta / 2)
        else:
            w = math3d.Vector()
        return (w, theta)
    
    def fromOrientation(self, orient, positive=True):
        ''' Set this quaternion to represent the given
        orientation. The used method should be robust;
        cf. http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation.
        The mentioned method from wikipedia has problems with certain
        orientations, like the identity. Therfore another robust
        method from
        http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
        is used; the one from "Angel"
        '''
        M = orient.data
        tr = M.trace() + 1.0
        if tr > 1e-10:
            s = 0.5 / numpy.sqrt(tr)
            self._s = 0.25 / s
            self._v.x = s * (M[2, 1] - M[1, 2])
            self._v.y = s * (M[0, 2] - M[2, 0])
            self._v.z = s * (M[1, 0] - M[0, 1])
        else:
            diag = M.diagonal()
            u = diag.argmax()
            v = (u + 1) % 3
            w = (v + 1) % 3
            r = numpy.sqrt(1 + M[u, u] - M[v, v] - M[w, w])
            if abs(r) < 1e-10:
                self._s = 1.0
                self._v = math3d.Vector(0, 0, 0)
            else:
                tworinv = 1.0 / (2 * r)
                self._s = (M[w, v] - M[v, w]) * tworinv
                #if not positive and self._s > 0:
                #    self._s *= -1
                self._v[u] = 0.5 * r
                self._v[v] = (M[u, v] + M[v, u]) * tworinv
                self._v[w] = (M[w, u] + M[u, w]) * tworinv
        if positive and self._s < 0:
            self *= -1.0
                        
    def toOrientation(self):
        ''' Return an orientation object representing the same
        rotation as this quaternion.'''
        ## Return an Orientation representing this quaternion
        self.normalize()
        s = self._s
        v = self._v
        x = v.x
        y = v.y
        z = v.z
        x2 = x**2
        y2 = y**2
        z2 = z**2
        return math3d.Orientation(numpy.array([
            [1 - 2 * (y2 + z2), 2 * x * y - 2 * s * z, 2 * s * y + 2 * x * z],
            [2 * x * y + 2 * s * z, 1 - 2 * (x2 + z2), -2 * s * x + 2 * y * z],
            [-2 * s * y + 2 * x * z, 2 * s * x + 2 * y * z, 1 - 2 * (x2 + y2)]
            ]))
    
    def norm(self):
        ''' Return the norm of this quaternion.'''
        return numpy.sqrt(self.norm2())
    
    def norm2(self):
        ''' Return the square of the norm of this quaternion.'''
        return self._s**2 + self._v.length2()

    def conjugate(self):
        ''' In-place conjugation of this quaternion.'''
        self._v = -self._v

    def conjugated(self):
        ''' Return a quaternion whith is th conjugated of this quaternion.'''
        qc = self.copy()
        qc.conjugate()
        return qc
        
    def normalize(self):
        ''' Normalize this quaternion. '''
        n = self.norm()
        if abs(n) < 1e-10:
            self._s = 1
            self._v = math3d.Vector(0.0, 0.0, 0.0)
        else:
            ninv = 1.0 / n
            self._s *= ninv
            self._v *= ninv
         
    def normalized(self):
        ''' Return a normalised version of this quaternion. '''
        q = Quaternion(self)
        q.normalize()
        return q

    def invert(self):
        ''' In-place inversion of this quaternion. '''
        n2 = self.norm2()
        self.conjugate()
        self *= 1 / n2
        
    def inverse(self):
        ''' Return an inverse of this quaternion.'''
        qi = self.copy()
        qi.invert()
        return qi  

if __name__ == '__main__':
    import readline
    import rlcompleter
    readline.parse_and_bind("tab: complete")

