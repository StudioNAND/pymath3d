'''
This file is part of pymath3d.

pymath3d is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

pymath3d is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with pymath3d.  If not, see <http://www.gnu.org/licenses/>.

Revision: $Rev$
ID: $Id$

Module implementing a 3d homogenous Transform class. The transform is
represented internally by an orientation and a vector object.
'''

from utils import isSequence
from copy import copy
import types

import numpy

from orientation import Orientation,isOrientation
from vector import Vector,isVector

def isTransform(t):
    #return type(t)==InstanceType and t.__class__==Transform
    return type(t)==Transform

class Transform(object):
    ''' A Transform is a member of SE(3), represented as a homogenous
    transformation matrix. It uses an Orientation in member "_o" to
    represent the orientation part and a Vector in member "_v" to
    represent the position part. '''

    class Error(Exception):
        ''' Exception class.'''
        def __init__(self, message):
            self.message = message
        def __repr__(self):
            return self.__class__ + '.Error :' + self.message

    @classmethod
    def canCreateOn(cls, *args):
        """ Query whether a transform, syntactically and by type, can
        be constructed on the given arguments."""
        if len(args) == 0:
            return True
        elif len(args) == 1:
            arg = args[0]
            if type(arg) == types.NoneType:
                return True
            elif type(arg) == Transform:
                return True
            elif hasattr(arg,'pos') and hasattr(arg,'orient') and \
                 Orientation.canCreateOn(arg.orient) and \
                 Vector.canCreateOn(arg.pos):
                return True
            elif isSequence(arg):
                return cls.canCreateOn(*arg)
            else:
                return False
        elif len(args) == 2:
            return \
                   Orientation.canCreateOn(args[0]) and \
                   Vector.canCreateOn(args[1]) \
                   or \
                   Orientation.canCreateOn(args[1]) and \
                   Vector.canCreateOn(args[0])
        elif len(args) == 4:
            return Orientation.canCreateOn(args[:3]) and \
                   Vector.canCreateOn(args[3])
        elif len(args) == 12:
            return Orientation.canCreateOn(args[:9]) and \
                   Vector.canCreateOn(args[9:])
        else:
            return False

    def __createOnSequence(self, args):
        if len(args) == 1 and isSequence(args[0]):
            self.__createOnSequence(args[0])
        elif len(args) == 2:
            if Orientation.canCreateOn(args[0]) \
                   and Vector.canCreateOn(args[1]):
                self._o = Orientation(args[0])
                self._v = Vector(args[1])
            elif Orientation.canCreateOn(args[1]) \
                   and Vector.canCreateOn(args[0]):
                self._o = Orientation(args[1])
                self._v = Vector(args[0])
            else:
                raise self.Error, \
                  "Could not create Transform on arguments : " + str(args)
        elif len(args) == 4:
            self._o = Orientation(args[:3])
            self._v = Vector(args[3])
        elif len(args) == 12:
            self._o = Orientation(args[:9])
            self._v = Vector(args[9:])
        elif len(args) == 0 or len(args) == 1 and \
                 type(args[0]) == types.NoneType:
            self._v = Vector()
            self._o = Orientation()
        else:
            raise self.Error, \
                  "Could not create Transform on arguments : " + str(args)
        
    def __init__(self, *args):
        if len(args) == 0 or len(args) == 1 and \
               type(args[0]) == types.NoneType:
            self._v = Vector()
            self._o = Orientation()
        elif len(args) == 1 :
            arg = args[0]
            if type(arg) == Transform or \
                   hasattr(arg,'pos') and hasattr(arg,'orient') and \
                   Orientation.canCreateOn(arg.orient) and \
                   Vector.canCreateOn(arg.pos):
                t = arg
                self._v = Vector(t.pos)
                self._o = Orientation(t.orient)
            else:
                raise self.Error, \
                      "Could not create Transform on arguments : ", str(args)                
        elif len(args) >= 1:
            self.__createOnSequence(args)
        else:
            raise self.Error, \
                  "Could not create Transform on arguments : ", str(args)

    def __getattr__(self, name):
        if name == 'orient':
            return self._o
        elif name == 'pos':
            return self._v
        else:
            raise AttributeError
        
    def __copy__(self):
        ''' Copy method for creating a (deep) copy of this Transform.'''
        t = Transform()
        t.copy(self)
        return t
    
    def __deepcopy__(self, memo):
        return self.__copy__()

    def copy(self, other):
        ''' Copy data from other to self. '''
        self._v = copy(other._v)
        self._o = copy(other._o)

    def __repr__(self):
        return "<Transform:\n" + repr(self._o) + '\n' + repr(self._v) + '>'

    def __str__(self):
        return self.__repr__()
    
    def __coerce__(self, other):
        print '!!!! Warning !!!!  : Coercion called on Transform!!!'
        if isTransform(other):
            return (self, other)
        elif isVector(other):
            return (self._v, other)
        elif isOrientation(other):
            return (self._o, other)
        else:
            return None
        
    def __eq__(self,other):
        if isTransform(other) and self._o == other._o and self._v == other._v:
            return True
        else:
            return False

    def fromXYP(self, cx, cy, p):
        ''' Make this transform correspond to the orientation given
        by the given x and y directions and translation given by p.'''
        self._o.fromXY(cx, cy)
        self._v.pos = p

    def fromXZP(self, cx, cz, p):
        ''' Make this transform correspond to the orientation given
        by the given x and z directions and translation given by p.'''
        self._o.fromXZ(cx, cz)
        self._v.pos = p

    def inverse(self):
        ''' Return an inverse.'''
        io = self._o.inverse()
        iv = io * (-self._v)
        return Transform(io, iv)

    def invert(self):
        ''' In-place invert.'''
        self._o.invert()
        self._v = self._o * (-self._v)

    def __mul__(self, other):
        ''' Multiplication of self with another object.'''
        if isTransform(other):
            o = self._o * other._o
            v = self._o * other._v + self._v
            return Transform(o, v)
        elif isVector(other):
            return self._o * other + other._isPosition * self._v
        elif isSequence(other):
            return map(self.__mul__,other)

    def toArray(self):
        ''' Return a tuple of an 3x3 orientation array and position as
        3-array.'''
        return (self._o._data.copy(),self._v._data.copy())

    def toList(self):
        ''' Return a list with orientation and position in list form.'''
        return [self._o._data.tolist(),self._v._data.tolist()]
    
def newTransFromXYP(cx, cy, p):
    ''' Create a transform corresponding to the orientation given by
    the given x and y directions and translation given by p.'''
    t = Transform()
    t.fromXYP(cx, cy, p)
    return t

def newTransFromXZP(cx, cz, p):
    ''' Create a transform corresponding to the orientation given by
    the given x and z directions and translation given by p.'''
    t = Transform()
    t.fromXZP(cx, cz, p)
    return t

def _test():
    cx = Vector(2, 3, 0)
    cz = Vector.e2
    p = Vector(1, 2, 3)
    t = newTransFromXZP(cx, cz, p)
    print t*cx
    it = t.inverse()

if __name__ == '__main__':
    _test()
