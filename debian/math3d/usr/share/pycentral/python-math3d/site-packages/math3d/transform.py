'''
Copyright (C) 2011 Morten Lind
mailto: morten@lind.no-ip.org

This file is part of PyMath3D (Math3D for Python).

PyMath3D is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

PyMoCo is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with PyMath3D.  If not, see <http://www.gnu.org/licenses/>.
'''
'''
Module implementing a 3D homogenous Transform class. The transform is
represented internally by associated orientation and a vector objects.
'''

import numpy

from math3d.orientation import Orientation,isOrientation
from math3d.vector import Vector,isVector
from math3d.utils import isSequence

def isTransform(t):
    return type(t)==Transform

class Transform(object):
    ''' A Transform is a member of SE(3), represented as a homogenous
    transformation matrix. It uses an Orientation in member "_o" to
    represent the orientation part and a Vector in member "_v" to
    represent the position part. '''

    class Error(Exception):
        ''' Exception class.'''
        def __init__(self, message):
            self.message = message
        def __repr__(self):
            return self.__class__ + '.Error :' + self.message

    @classmethod
    def canCreateOn(cls, *args):
        """ Query whether a transform, syntactically and by type, can
        be constructed on the given arguments."""
        if len(args) == 0:
            return True
        elif len(args) == 1:
            arg = args[0]
            if type(arg) == type(None):
                return True
            elif type(arg) == Transform:
                return True
            elif type(arg) == numpy.ndarray and arg.shape==(4,4):
                return True
            elif hasattr(arg,'pos') and hasattr(arg,'orient') and \
                 Orientation.canCreateOn(arg.orient) and \
                 Vector.canCreateOn(arg.pos):
                return True
            elif isSequence(arg):
                return cls.canCreateOn(*arg)
            else:
                return False
        elif len(args) == 2:
            return \
                   Orientation.canCreateOn(args[0]) and \
                   Vector.canCreateOn(args[1]) \
                   or \
                   Orientation.canCreateOn(args[1]) and \
                   Vector.canCreateOn(args[0])
        elif len(args) == 4:
            return Orientation.canCreateOn(args[:3]) and \
                   Vector.canCreateOn(args[3])
        elif len(args) == 12:
            return Orientation.canCreateOn(args[:9]) and \
                   Vector.canCreateOn(args[9:])
        else:
            return False

    def __createOnSequence(self, args):
        if len(args) == 1 and isSequence(args[0]):
            self.__createOnSequence(args[0])
        elif len(args) == 2:
            if Orientation.canCreateOn(args[0]) \
                   and Vector.canCreateOn(args[1]):
                self._o = Orientation(args[0])
                self._v = Vector(args[1])
            elif Orientation.canCreateOn(args[1]) \
                   and Vector.canCreateOn(args[0]):
                self._o = Orientation(args[1])
                self._v = Vector(args[0])
            else:
                raise self.Error(
                    "Could not create Transform on arguments : " + str(args))
        elif len(args) == 4:
            self._o = Orientation(args[:3])
            self._v = Vector(args[3])
        elif len(args) == 12:
            self._o = Orientation(args[:9])
            self._v = Vector(args[9:])
        elif len(args) == 0 or len(args) == 1 and \
                 type(args[0]) == type(None):
            self._v = Vector()
            self._o = Orientation()
        else:
            raise self.Error(
                "Could not create Transform on arguments : " + str(args))
        
    def __init__(self, *args):
        if len(args) == 0 or len(args) == 1 and \
               type(args[0]) == type(None):
            self._v = Vector()
            self._o = Orientation()
        elif len(args) == 1 :
            arg = args[0]
            if type(arg) == Transform or \
                   hasattr(arg,'pos') and hasattr(arg,'orient') and \
                   Orientation.canCreateOn(arg.orient) and \
                   Vector.canCreateOn(arg.pos):
                t = arg
                self._v = t.pos.copy()
                self._o = t.orient.copy()
            elif type(arg) == numpy.ndarray and arg.shape==(4,4):
                self._o = Orientation(arg[:3,:3].copy())
                self._v = Vector(arg[:3,3].copy())
            else:
                raise self.Error(
                    "Could not create Transform on arguments : " + str(args))
        elif len(args) >= 1:
            self.__createOnSequence(args)
        else:
            raise self.Error(
                "Could not create Transform on arguments : " + str(args))
        self._setFromOV(self._o, self._v)
        
    def _setFromOV(self, o, v):
        self._data = numpy.identity(4)
        ## First take over the data from Orientation and Vector
        self._data[:3,:3] = o._data
        self._data[:3,3] = v._data
        ## Then share data with Orientation and Vector.
        self._o._data = self._data[:3,:3]
        self._v._data = self._data[:3,3]
        
    def __getattr__(self, name):
        if name == 'data':
            return self._data.copy()
        elif name == 'orient':
            return self._o
        elif name == 'pos':
            return self._v
        else:
            raise AttributeError
        
    def __setattr__(self, name, value):
        if name == 'orient':
            if type(value) == numpy.ndarray:
                self._data[:3,:3] = value
            elif type(value) == Orientation:
                self._data[:3,:3] = value._data
        elif name == 'pos':
            if type(value) == numpy.ndarray:
                self._data[:3,3] = value
            elif type(value) == Vector:
                self._data[:3,3] = value._data
        else:
            self.__dict__[name] = value
            
    def __copy__(self):
        ''' Copy method for creating a (deep) copy of this Transform.'''
        return Transform(self)
    
    def __deepcopy__(self, memo):
        return self.__copy__()

    def copy(self, other=None):
        ''' Copy data from other to self. '''
        if other is None:
            return Transform(self)
        else:
            self._data[:,:] = other._data.copy()
        
    def __repr__(self):
        return "<Transform:\n" + repr(self.orient) + '\n' + repr(self.pos) + '>'

    def __str__(self):
        return self.__repr__()
    
    def __coerce__(self, other):
        print('!!!! Warning !!!!  : Coercion called on Transform!!!')
        if isTransform(other):
            return (self, other)
        elif isVector(other):
            return (self.pos, other)
        elif isOrientation(other):
            return (self.orient, other)
        else:
            return None
        
    def __eq__(self,other):
        #if isTransform(other) and self._o == other._o and self._v == other._v:
        if type(other) == Transform and numpy.sum((self._data-other._data)**2) < 0.001:
            return True
        else:
            return False

    def fromXYP(self, cx, cy, p):
        ''' Make this transform correspond to the orientation given
        by the given x and y directions and translation given by p.'''
        self._o.fromXY(cx, cy)
        self._v.pos = p
        self._setFromOV(self._o, self._v)
        
    def fromXZP(self, cx, cz, p):
        ''' Make this transform correspond to the orientation given
        by the given x and z directions and translation given by p.'''
        self._o.fromXZ(cx, cz)
        self._v.pos = p
        self._setFromOV(self._o, self._v)

    def inverse(self):
        ''' Return an inverse.'''
        #io = self._o.inverse()
        #iv = io * (-self._v)
        #return Transform(io, iv)
        return Transform(numpy.linalg.inv(self._data))
    
    def invert(self):
        ''' In-place invert.'''
        #self._o.invert()
        # self._v = self._o * (-self._v)
        self._data[:,:]=numpy.linalg.inv(self._data)
        
    def __mul__(self, other):
        ''' Multiplication of self with another object.'''
        if isTransform(other):
            #o = self._o * other._o
            #v = self._o * other._v + self._v
            #return Transform(o, v)
            return Transform(numpy.dot(self._data, other._data))
        elif isVector(other):
            #return self._o * other + other._isPosition * self._v
            v = numpy.ones(4)
            v[:3] = other._data
            return Vector(numpy.dot(self._data, v)[:3])
        elif isSequence(other):
            return list(map(self.__mul__,other))

    def toArray(self):
        ''' Return a tuple of an 3x3 orientation array and position as
        3-array.'''
        #return (self._o._data.copy(),self._v._data.copy())
        return (self._data[:3,:3], self._data[:3,3])
    
    def toList(self):
        ''' Return a list with orientation and position in list form.'''
        #return [self._o._data.tolist(),self._v._data.tolist()]
        return [self._data[:3,:3].tolist(), self._data[:3,3].tolist()]
    
def newTransFromXYP(cx, cy, p):
    ''' Create a transform corresponding to the orientation given by
    the given x and y directions and translation given by p.'''
    t = Transform()
    t.fromXYP(cx, cy, p)
    return t

def newTransFromXZP(cx, cz, p):
    ''' Create a transform corresponding to the orientation given by
    the given x and z directions and translation given by p.'''
    t = Transform()
    t.fromXZP(cx, cz, p)
    return t

def _test():
    cx = Vector(2, 3, 0)
    cz = Vector.e2
    p = Vector(1, 2, 3)
    t = newTransFromXZP(cx, cz, p)
    print((t*cx))
    it = t.inverse()

if __name__ == '__main__':
    _test()
